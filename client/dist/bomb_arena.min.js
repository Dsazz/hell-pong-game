(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.game = new Phaser.Game(480, 640, Phaser.AUTO, '');
window.player = null;
window.socket = null;
window.level = null;
window.TEXTURES = "bbo_textures";

startGame();

function startGame() {
	//socket = io("https://test-pong-dsazz.c9users.io:443");
    socket = io("http://localhost:8080");

    require("./game/mods/phaser_enhancements");

	game.state.add("Boot", require("./game/states/boot"));
	game.state.add("Preloader", require("./game/states/preloader"));
	game.state.add("TitleScreen", require("./game/states/title_screen"));
	game.state.add("Lobby", require("./game/states/lobby"));
	game.state.add("StageSelect", require("./game/states/stage_select"));
	game.state.add("PendingGame", require("./game/states/pending_game"));
	game.state.add("Level", require("./game/states/level"));
	game.state.add("GameOver", require("./game/states/game_over"));

	game.state.start('Boot');
};

},{"./game/mods/phaser_enhancements":6,"./game/states/boot":7,"./game/states/game_over":8,"./game/states/level":9,"./game/states/lobby":10,"./game/states/pending_game":11,"./game/states/preloader":12,"./game/states/stage_select":13,"./game/states/title_screen":14}],2:[function(require,module,exports){
var AudioPlayer = require("../util/audio_player");

var DEFAULT_BALL_SPEED = 640 * 0.25;

var Ball = function(x, y) {
    Phaser.Sprite.call(
        this, game, x, y, 'pong_textures', 'ball/ball_01'
    );

    game.physics.arcade.enable(this);
    this.checkWorldBounds = true;
    this.body.collideWorldBounds = true;
    this.body.bounce.set(1);

    this.animations.add(
        'spin', ['ball/ball_01', 'ball/ball_02', 'ball/ball_03'], 50, true, false
    );

    this.x = x;
    this.y = y;
    this.spawnPoint = {x: x, y: y};

    this.anchor.set(0.5);

    this.speed = DEFAULT_BALL_SPEED;
    this.isOnPaddle = false;
};

Ball.prototype = Object.create(Phaser.Sprite.prototype);
Ball.prototype.constructor = Ball;

Ball.prototype.resetState = function() {
    this.body.velocity.y = 0;
    this.body.velocity.x = 0;
    this.speed = DEFAULT_BALL_SPEED;
    this.animations.play('spin');
    this.x = this.spawnPoint.x;
    this.y = this.spawnPoint.y;
};

Ball.prototype.startDirection = function(direction) {
    switch (direction) {
        case 'UP':
            this.body.velocity.y = -this.speed;
            break;
        case 'DOWN':
            this.body.velocity.y = this.speed;
            break;
    }
};

module.exports = Ball;

},{"../util/audio_player":15}],3:[function(require,module,exports){
var DEFAULT_PLAYER_SPEED = 300;

var Player = function(x, y, id, name, leftKey, rightKey) {
    Phaser.Sprite.call(this, game, x, y, 'pong_textures', 'paddle/paddle');

    this.id = id;

    this.leftKey = game.input.keyboard.addKey(leftKey || Phaser.Keyboard.LEFT);
    this.rightKey = game.input.keyboard.addKey(rightKey || Phaser.Keyboard.RIGHT);
    this.score = 0;
    this.name = name || 'Player ' + id;
    this.speed = DEFAULT_PLAYER_SPEED;

    this.spawnPoint = {
        x: x,
        y: y
    };

    game.physics.arcade.enable(this);
    this.body.bounce.set(1);
    this.anchor.set(0.5);

    game.add.existing(this);
};

Player.prototype = Object.create(Phaser.Sprite.prototype);
Player.prototype.constructor = Player;

Player.prototype.scoreInc = function() {
    this.score += 1;
};

Player.prototype.reset = function() {
    this.x = this.spawnPoint.x;
    this.y = this.spawnPoint.y;
    this.speed = DEFAULT_PLAYER_SPEED;

    if (!this.alive) {
        this.revive();
    }
};

Player.prototype.handleInput = function() {
    var moving = true;
    if (this.leftKey.isDown) {
        this.body.velocity.x = -this.speed;
    } else if (this.rightKey.isDown) {
        this.body.velocity.x = this.speed;
    } else {
        moving = false;
        this.freeze();
    }

    if (moving) {
        socket.emit("move player", {
            //x: this.position.x,
            //y: this.position.y
            x: this.body.velocity.x,
            timeMovement: this.game.time.now
        });
    }
};

Player.prototype.freeze = function() {
    this.body.velocity.x = 0;
};

module.exports = Player;

},{}],4:[function(require,module,exports){
var remotePlayerUpdateInterval = 100;

var RemotePlayer = function(x, y, id, name) {
    this.id = id;
    this.lastMoveTime = 0;
    this.targetPositionX;
    this.spawnPoint = {x: x, y: y};
    this.name = name || 'Player ' + id;
    this.score = 0;

    Phaser.Sprite.call(this, game, x, y, 'pong_textures', 'paddle/paddle');

    game.physics.enable(this, Phaser.Physics.ARCADE);
    this.body.bounce.set(1);

    this.anchor.set(0.5);

    game.add.existing(this);
};

RemotePlayer.prototype = Object.create(Phaser.Sprite.prototype);

RemotePlayer.prototype.move = function(velocity) {
    this.body.velocity.x = velocity;

    var currentTime = new Date().getTime();
    this.lastMoveTime = currentTime;
};

RemotePlayer.prototype.isMovementTimeExpired = function() {
    var currentTime = new Date().getTime();
    return this.lastMoveTime+10 <= currentTime;
}

RemotePlayer.prototype.reset = function() {
    this.x = this.spawnPoint.x;
    this.y = this.spawnPoint.y;
    this.targetPositionX = null
    this.lastMoveTime = 0;
    this.score = 0;

    if(!this.alive) {
        this.revive();
    }
};

module.exports = RemotePlayer;

},{}],5:[function(require,module,exports){
var TextConfigurer = require('../util/text_configurer');

var screenWidth = 600;

var xOffset = 100 - screenWidth;
var yOffset = 60;

var headerXOffset = 150 - screenWidth;
var headerYOffset = 65;

var winnerPicXOffset = 225 - screenWidth;
var winnerPicYOffset = 310;

var defaultTextXOffset = 220 - screenWidth;
var defaultTextYOffset = 220;

var singleWinnerText = "Winner is...";
var roundEndTieText = "Draw! Winners are...";

function RoundEndAnimation(game, roundNumber, winningColors) {
	Phaser.Group.call(this, game);

	var roundEndWindow = game.add.image(xOffset, yOffset, TEXTURES, "lobby/end_of_round_window.png");

	var header = game.add.text(headerXOffset, headerYOffset, "Round " + roundNumber + " Complete!")
	TextConfigurer.configureText(header, "white", 32);

	// Text and offset differ based on whether or not there was a tie.
	var actualTextXOffset = winningColors.length > 1 ? defaultTextXOffset - 55 : defaultTextXOffset;
	var actualTextToDisplay = winningColors.length > 1 ? roundEndTieText : singleWinnerText;

	var textObject = game.add.text(actualTextXOffset, defaultTextYOffset, actualTextToDisplay);
	TextConfigurer.configureText(textObject, "white", 28);
	textObject.alpha = 0;

	this.add(roundEndWindow);
	this.add(header);
	this.add(textObject);
	
	this.createAndAddWinnerImages(winningColors);
};

RoundEndAnimation.prototype = Object.create(Phaser.Group.prototype);

RoundEndAnimation.prototype.createAndAddWinnerImages = function(winningColors) {
	this.winnerImageIndices = [];
	var index = 3; // 3 is the index of the first winner image.

	winningColors.forEach(function(color) {
		var winnerPicImage = new Phaser.Image(game, winnerPicXOffset, winnerPicYOffset, TEXTURES, "lobby/bomberman_head/bomberman_head_" + color + ".png");

		winnerPicImage.scale = {x: 1.75, y: 1.75};
		winnerPicImage.alpha = 0;

		game.add.existing(winnerPicImage);
		this.add(winnerPicImage);
		this.winnerImageIndices.push(index++);
	}, this);
};

RoundEndAnimation.prototype.beginAnimation = function(callback) {
	var entranceTween = game.add.tween(this);
	entranceTween.to({x: screenWidth}, 300);
	entranceTween.onComplete.addOnce(function() {
		winnerTextTween.start();
	}, this);

	var winnerTextTween = game.add.tween(this.children[2]);
	winnerTextTween.to({alpha: 1}, 800);
	winnerTextTween.onComplete.addOnce(function() {
		winnerDisplayTween.start();
	}, this);

	var exitTween = game.add.tween(this);
	exitTween.to({x: 2 * screenWidth}, 300, Phaser.Easing.Default, false, 200);
	exitTween.onComplete.addOnce(function() {
		callback();
		this.destroy();
	}, this);

	var winnerDisplayTween = this.generateWinnerImageTween(this.winnerImageIndices, exitTween);

	entranceTween.start();
};


module.exports = RoundEndAnimation;
},{"../util/text_configurer":17}],6:[function(require,module,exports){
/**
* Modified this method to be able to ignore certain children, so that select elements (such as scrolling background) can be preserved
* between states.
*/
Phaser.Group.prototype.removeAll = function (destroy, silent) {

    if (typeof destroy === 'undefined') { destroy = false; }
    if (typeof silent === 'undefined') { silent = false; }

    if (this.children.length === 0)
    {
        return;
    }

    var i = 0;

    do
    {
        if(this.children[i].doNotDestroy) {
            i++;
        }

        if (!silent && this.children[i].events)
        {
            this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);
        }

        var removed = this.removeChild(this.children[i]);

        if (destroy && removed)
        {
            removed.destroy(true);
        }
    }
    while (this.children.length > i);

    this.cursor = null;

};
},{}],7:[function(require,module,exports){
var AudioPlayer = require("../util/audio_player");

var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    this.load.bitmapFont('retro_font', 'assets/fonts/retro_font.png', 'assets/fonts/retro_font.xml');
  },

  create: function () {
    game.stage.disableVisibilityChange = true; // So that game doesn't stop when window loses focus.
    game.input.maxPointers = 1;
    AudioPlayer.initialize();
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    
    if (game.device.desktop) {
      game.stage.scale.pageAlignHorizontally = true;
    } else {
      game.scale.minWidth =  480;
      game.scale.minHeight = 260;
      game.scale.maxWidth = 640;
      game.scale.maxHeight = 480;
      game.scale.forceLandscape = true;
      game.scale.pageAlignHorizontally = true;
      game.scale.updateLayout (true);
    }

    game.state.start('Preloader');
  }
};

},{"../util/audio_player":15}],8:[function(require,module,exports){
function GameOver() {
}

GameOver.prototype = {
	init: function(winnerName, winByDefault) {
		this.winnerName = winnerName;
		this.winByDefault = winByDefault;
	},

	create: function() {
		var textToDisplay = this.winByDefault 
			? "     No other players remaining.\n              You win by default." 
			: "       Game Over. Winner: " + this.winnerName;
		textToDisplay += "\n\nPress Enter to return to main menu.";
		var textObject = game.add.text(game.camera.width/2, game.camera.height/2, textToDisplay);
		textObject.anchor.set(0.5);
	},

	update: function() {
		if(game.input.keyboard.isDown(Phaser.Keyboard.ENTER)) {
			this.returnToLobby();
		}
	},

	returnToLobby: function() {
		game.state.start("Lobby");
	}
}

module.exports = GameOver;
},{}],9:[function(require,module,exports){
var BLACK_HEX_CODE = "#000000";
var TILE_SIZE = 40;

var AudioPlayer = require("../util/audio_player");
var Player = require("../entities/player");
var RemotePlayer = require("../entities/remoteplayer");
var Ball = require("../entities/ball");
var RoundEndAnimation = require("../entities/round_end_animation");

var Level = function () {};

module.exports = Level;

Level.prototype = {

    init: function(tilemapName, players, id) {
        this.tilemapName = tilemapName;
        this.players = players;
        this.playerId = '/#' + id;
        this.remotePlayers = {},
            this.gameFrozen = true,
                this.isGameOver = false
    },

    setEventHandlers: function() {
        // Remember - these will actually be executed from the context of the Socket, not from the context of the level.
        socket.on("disconnect", this.onSocketDisconnect);
        socket.on("m", this.onMovePlayer.bind(this));
        socket.on("new round", this.onNewRound.bind(this));
        socket.on("end game", this.onEndGame.bind(this));
        socket.on("no opponents left", this.onNoOpponentsLeft.bind(this));
    },

    create: function () {
        level = this;

        this.lastFrameTime;
        this.initializeStage();
        //this.launchPlayerScoreTable();

        this.ball = this.game.add.existing(
            new Ball(
                game.camera.width/2,
                game.camera.height/2
            )
        );
        this.ball.events.onOutOfBounds.add(this.ballLost, this);

        //this.launchIntroText();

        this.setEventHandlers();
        this.initializePlayers();

        //this.beginRoundAnimation("round_text/round_1.png");
        //
        //Event on click board start game
        //game.input.onDown.add(this.onNewRound, this);
        this.onNewRound();

    },

    initializeStage: function() {
        game.physics.startSystem(Phaser.Physics.ARCADE);
        //var background = game.add.sprite(0, 0, 'pong_textures', 'lobby/lobby_bg');

        //  We check bounds collisions against all walls other than the bottom one
        game.physics.arcade.checkCollision.down = false;
        game.physics.arcade.checkCollision.up = false;
    },


    restartGame: function() {
        player.reset();
        for(var i in this.remotePlayers) {
            this.remotePlayers[i].reset();
        }

        this.lastFrameTime;
        this.gameFrozen = false;

        socket.emit("ready for round");
    },

    onNewRound: function(data) {
        //this.gameFrozen = true;
        //if (this.checkIsNewGame() || this.isGameOver) {
        console.log('Game started');
        if (this.isGameOver) {
            this.playerGroup.setAll('score', 0);
            //this.playerScoreTableGroup.setAll('text', '0');
            this.isGameOver = false;
        }

        this.gameFrozen = false;

        this.ball.body.velocity.y = -this.ball.speed;
        this.ball.body.velocity.x = 0;
        this.ball.animations.play('spin');

        //this.introText.visible = false;

        //this.playerScoreTableGroup.setAll('visible', true);
        //}
    },

    checkIsNewGame: function() {
        return false === this.gameFrozen && false === this.isGameOver;
    },

    onEndGame: function(data) {
        //this.gameFrozen = true;
        var animation = new RoundEndAnimation(game, data.completedRoundNumber, data.roundWinnerColors);
        animation.beginAnimation(function() {
            game.state.start("GameOver", true, false, data.gameWinnerColor, false);
        });
    },

    onNoOpponentsLeft: function(data) {
        game.state.start("GameOver", true, false, null, true);
    },

    update: function() {
        game.physics.arcade.collide(
            this.ball, this.playerGroup, this.ballHitPaddle, null, this
        );

        if(player != null && player.alive === true) {
            if(this.gameFrozen) {
                player.freeze();
            } else {
                player.handleInput();
            }
        }

        //TODO change array to one entity
        for(var id in this.remotePlayers) {
            if (this.remotePlayers[id].isMovementTimeExpired())
                this.remotePlayers[id].move(0);
        }

    },

    onSocketDisconnect: function() {
        console.log("Disconnected from socket server.");

        this.broadcast.emit("remove player", {id: this.id});
    },

    initializePlayers: function() {
        this.playerGroup = this.game.add.physicsGroup();

        for(var i in this.players) {
            var data = this.players[i];
            if(data.id == this.playerId) {
                player = new Player(
                    data.x, data.y, data.id, data.name
                );
                this.playerGroup.add(player);

            } else {
                this.remotePlayers[data.id] = new RemotePlayer(
                    data.x, data.y, data.id, data.name
                );

                this.playerGroup.add(this.remotePlayers[data.id]);
            }
        }

        this.playerGroup.setAll('body.immovable', true);
        this.playerGroup.setAll('body.collideWorldBounds', true);
    },

    onMovePlayer: function(data) {
        if(player && data.id == player.id || this.gameFrozen) {
            return;
        }

        var movingPlayer = this.remotePlayers[data.id];

        movingPlayer.lastMoveTime = data.timeMovement;
        movingPlayer.move(data.x);
    },

    ballHitPaddle: function(ball, player) {
        var diff = 0;
        if (ball.x < player.x) {
            diff = player.x - ball.x;
            //  Ball is on the left-hand side of the paddle
            ball.body.velocity.x = (-10 * diff);
        } else if (ball.x > player.x) {
            //  Ball is on the right-hand side of the paddle
            diff = ball.x - player.x;
            ball.body.velocity.x = (10 * diff);
        } else {
            //  Ball is perfectly in the middle
            //  Add a little random X to stop it bouncing straight up!
            ball.body.velocity.x = 2 + Math.random() * 10;
        }
    },

    ballLost: function() {

        if (this.ball.y > this.game.height) {
            //this.playerTwo.scoreInc();
            //this.playerTwoScoreTable.text = this.playerTwo.score;
            this.ball.resetState();
            this.ball.startDirection('DOWN');
        }

        if (this.ball.y < 0) {
            //this.playerOne.scoreInc();
            //this.playerOneScoreTable.text = this.playerOne.score;
            this.ball.resetState();
            this.ball.startDirection('UP');
        }

        //if (this.playerOne.score > 1) {
        //    this.gameOver(this.playerOne.name);
        //}
        //if (this.playerTwo.score > 1) {
        //    this.gameOver(this.playerTwo.name);
        //}
    }
};

},{"../entities/ball":2,"../entities/player":3,"../entities/remoteplayer":4,"../entities/round_end_animation":5,"../util/audio_player":15}],10:[function(require,module,exports){
var Lobby = function() {};
var repeatingLavaTilesprite;

module.exports = Lobby;

Lobby.prototype = {
    init: function(rbts) {
        repeatingLavaTilesprite = rbts;
    },

    create: function() {
        this.stateSettings = {
            empty: {
                outFrame: "lobby/slots/slot_01",
                overFrame: "lobby/slots/slot_02",
                text: "Host Game ", // For some reason, text gets slightly truncated if I don't append a space.
                callback: this.hostGameAction
            },
            joinable: {
                outFrame: "lobby/slots/slot_03",
                overFrame: "lobby/slots/slot_04",
                text: "Join Game ",
                callback: this.joinGameAction
            },
            settingup: {
                outFrame: "lobby/slots/slot_05",
                overFrame: "lobby/slots/slot_05",
                text: "Game is being set up... ",
                callback: null
            },
            inprogress: {
                outFrame: "lobby/slots/slot_05",
                overFrame: "lobby/slots/slot_05",
                text: "Game in Progress ",
                callback: null
            },
            full: {
                outFrame: "lobby/slots/slot_05",
                overFrame: "lobby/slots/slot_05",
                text: "Game Full ",
                callback: null
            }
        };

        if(repeatingLavaTilesprite == null) {
            repeatingLavaTilesprite = game.add.tileSprite(0, 0, 480, 640, "pong_textures", "lobby/lobby_bg");
        }

        repeatingLavaTilesprite.doNotDestroy = true;

        this.backdrop = game.add.image(20, 25, "pong_textures", "lobby/lobby_backdrop");
        this.header = game.add.bitmapText(
            this.backdrop.width/2, 
            this.backdrop.height * 0.1, 
            "retro_font",
            "Lobby",
            25
        );
        this.header.anchor.set(0.5);
        this.backdrop.addChild(this.header);

        this.slots = [];
        this.labels = [];

        var gameData = [{state: "empty"}, {state: "empty"}, {state: "joinable"}, {state: "insession"}];

        socket.emit("enter lobby");

        if(!socket.hasListeners("add slots")) {
            socket.on("add slots", this.addSlots.bind(this));
            socket.on("update slot", this.updateSlot.bind(this));
        }
    },

    update: function() {
        repeatingLavaTilesprite.tilePosition.x++;
        repeatingLavaTilesprite.tilePosition.y--;
    },

    addSlots: function(gameData) {
        if(this.slots.length > 0)  // TODO: get rid of this
            return;

        var initialSlotYOffset = this.backdrop.height * 0.2;
        var slotXOffset = this.backdrop.width/2 * 0.1;
        var lobbySlotDistance = 60;

        for(var i = 0; i < gameData.length; i++) {
            var callback = null;
            var state = gameData[i].state;
            var settings = this.stateSettings[state];

            (function(n, fn) {
                if(fn != null) {
                    callback = function() {
                        fn(n);
                    }
                }
            })(i, settings.callback);

            var slotYOffset = initialSlotYOffset + i * lobbySlotDistance;
            this.slots[i] = game.add.button(slotXOffset, slotYOffset, "pong_textures", callback, null, settings.overFrame, settings.outFrame);
            this.slots[i].setDownSound(buttonClickSound);
            
            var text = game.add.bitmapText(
                this.slots[i].width/2+5, 
                this.slots[i].height/2, 
                "retro_font",
                settings.text,
                20
            );
            text.anchor.set(0.5);
            
            this.slots[i].addChild(text);
            this.backdrop.addChild(this.slots[i]);

            this.labels[i] = text;
        }
    },

    hostGameAction: function(gameId) {
        socket.emit("host game", {gameId: gameId});
        socket.removeAllListeners();
        game.state.start("StageSelect", true, false, gameId, repeatingLavaTilesprite);
    },

    joinGameAction: function(gameId) {
        socket.removeAllListeners();
        game.state.start("PendingGame", true, false, null, gameId, repeatingLavaTilesprite);
    },

    updateSlot: function(updateInfo) {
        var settings = this.stateSettings[updateInfo.newState];
        var id = updateInfo.gameId;
        var button = this.slots[id];

        this.labels[id].text = settings.text;
        button.setFrames(settings.overFrame, settings.outFrame);

        // Change callback of button
        button.onInputUp.removeAll();
        button.onInputUp.add(function() { return settings.callback(id)}, this);
    }
};

},{}],11:[function(require,module,exports){
var TextConfigurer = require('../util/text_configurer');

var PendingGame = function() {}

module.exports = PendingGame;

var xOffset = 20;
var yOffset = 25;

var buttonXOffset = 330;
var startGameButtonYOffset = 250;
var leaveButtonYOffset = 300;

var characterSquareXDistance = 105;

var characterOffsetX = 4.5;
var characterOffsetY = 4.5;

var minPlayerMessageOffsetY = 200;

var repeatingLavaTilesprite;

PendingGame.prototype = {
    init: function(tilemapName, gameId, rbts) {
        this.tilemapName = tilemapName;
        this.gameId = gameId;
        repeatingLavaTilesprite = rbts;
    },

    create: function() {
        socket.emit("enter pending game", {gameId: this.gameId});

        this.backdrop = game.add.image(xOffset, yOffset, "pong_textures", "lobby/lobby_backdrop");

        var backdropCenterX = this.backdrop.width/2;
        this.startGameButton = game.add.button(backdropCenterX, startGameButtonYOffset, TEXTURES, null, this,
            "lobby/buttons/start_game_button_03.png", "lobby/buttons/start_game_button_03.png");
        this.startGameButton.anchor.set(0.5);

        this.leaveGameButton = game.add.button(backdropCenterX, leaveButtonYOffset, TEXTURES, this.leaveGameAction, null, 
            "lobby/buttons/leave_game_button_02.png", "lobby/buttons/leave_game_button_01.png");
        this.leaveGameButton.anchor.set(0.5);

        this.leaveGameButton.setDownSound(buttonClickSound);

        this.characterSquares = this.drawCharacterSquares();
        this.characterImages = [];
        this.numPlayersInGame = 0;

        this.minPlayerMessage = game.add.text(backdropCenterX, minPlayerMessageOffsetY, "Cannot start game\nwithout 2 players.")
        TextConfigurer.configureText(this.minPlayerMessage, "red", 17);
        this.minPlayerMessage.anchor.set(0.5);
        this.minPlayerMessage.visible = false;

        this.backdrop.addChild(this.startGameButton);
        this.backdrop.addChild(this.leaveGameButton);
        this.backdrop.addChild(this.minPlayerMessage);

        socket.on("show current players", this.populateCharacterSquares.bind(this));
        socket.on("player joined", this.playerJoined.bind(this));
        socket.on("player left", this.playerLeft.bind(this));
        socket.on("start game on client", this.startGame);
    },

    update: function() {
        repeatingLavaTilesprite.tilePosition.x++;
        repeatingLavaTilesprite.tilePosition.y--;
    },

    drawCharacterSquares: function() {
        var squareWidth = 89;
        var xOffset = this.backdrop.width/2 - squareWidth;
        var yOffset = this.backdrop.height * 0.15;
        var squareFrame = "lobby/slots/character_square_01.png";

        var firstSquare = game.add.sprite(xOffset, yOffset, TEXTURES, squareFrame);
        var secondSquare = game.add.sprite(xOffset + characterSquareXDistance, yOffset, TEXTURES, squareFrame);

        this.backdrop.addChild(firstSquare);
        this.backdrop.addChild(secondSquare);

        var characterSquares = [];
        characterSquares[0] = firstSquare;
        characterSquares[1] = secondSquare;

        return characterSquares;
    },

    populateCharacterSquares: function(data) {
        this.numPlayersInGame = 0;

        for(var playerId in data.players) {
            var color = data.players[playerId].color;
            this.characterImages[playerId] = game.add.image(
                this.characterSquares[this.numPlayersInGame].position.x + characterOffsetX,
                this.characterSquares[this.numPlayersInGame].position.y + characterOffsetY,
                TEXTURES,
                "lobby/bomberman_head/bomberman_head_" + color + ".png"
            );
            this.backdrop.addChild(this.characterImages[playerId]);

            this.numPlayersInGame++;
        }

        if(this.numPlayersInGame > 1) {
            this.activateStartGameButton();
        } else {
            this.minPlayerMessage.visible = true;
        }
    },

    playerJoined: function(data) {
        this.numPlayersInGame++;
        var index = this.numPlayersInGame - 1;

        this.characterImages[data.id] = game.add.image(
            this.characterSquares[index].position.x + characterOffsetX,
            this.characterSquares[index].position.y + characterOffsetY,
            TEXTURES,
            "lobby/bomberman_head/bomberman_head_" +  data.color + ".png"
        );
        this.backdrop.addChild(this.characterImages[data.id]);

        // Activate start game button if this is the second player to join the game.
        if(this.numPlayersInGame == 2) {
            this.activateStartGameButton();
        }
    },

    activateStartGameButton: function() {
        this.minPlayerMessage.visible = false;
        this.startGameButton.setFrames("lobby/buttons/start_game_button_02.png", "lobby/buttons/start_game_button_01.png");
        this.startGameButton.onInputUp.removeAll();
        this.startGameButton.onInputUp.add(this.startGameAction, this);
        this.startGameButton.setDownSound(buttonClickSound);
    },

    deactivateStartGameButton: function() {
        this.minPlayerMessage.visible = true;
        this.startGameButton.setFrames("lobby/buttons/start_game_button_03.png", "lobby/buttons/start_game_button_03.png");
        this.startGameButton.onInputUp.removeAll();
        this.startGameButton.setDownSound(null);
    },

    playerLeft: function(data) {
        this.numPlayersInGame--;

        if(this.numPlayersInGame == 1) {
            this.deactivateStartGameButton();
        }

        for(var playerId in this.characterImages) {
            this.characterImages[playerId].destroy();
        }
        this.populateCharacterSquares(data);
    },

    // When the "start" button is clicked, send a message to the server to initialize the game.
    startGameAction: function() {
        socket.emit("start game on server");
    },

    leaveGameAction: function() {
        socket.emit("leave pending game");
        socket.removeAllListeners();
        game.state.start("Lobby", true, false, repeatingLavaTilesprite);
    },

    startGame: function(data) {
        repeatingLavaTilesprite.doNotDestroy = false;
        socket.removeAllListeners();
        game.state.start("Level", true, false, data.mapName, data.players, this.id);
    }
}

},{"../util/text_configurer":17}],12:[function(require,module,exports){
var Preloader = function () {};

module.exports = Preloader;

Preloader.prototype = {

  displayLoader: function() {
    this.text = game.add.bitmapText(
      game.world.centerX, 
      game.world.centerY, 
      "retro_font",
      "Loading... ",
      30
    );
    this.text.anchor.setTo(.5, .5);

    this.load.onFileComplete.add(function(progress) {
        this.text.setText("Loading... " + progress + "%");
    }, this);

    this.load.onLoadComplete.add(function() {
        game.state.start("TitleScreen");
    });
  },

  preload: function () {
    this.displayLoader();

    this.load.atlasJSONHash("bbo_textures", "assets/textures/bbo_textures.png", "assets/textures/bbo_textures.json");
    this.load.atlasJSONHash("pong_textures", "assets/textures/pong_textures.png", "assets/textures/pong_textures.json");

    this.load.audio("click", "assets/sounds/click.ogg");
    this.load.audio("main_theme", "assets/sounds/main_theme.ogg");

    window.buttonClickSound = new Phaser.Sound(game, "click", .25);
  }
};

},{}],13:[function(require,module,exports){
var StageSelect = function() {};

module.exports = StageSelect;

var repeatingLavaTilesprite;

var stages = [
    {name: "Limitless Brook", thumbnailKey: "thumbnails/limitless_brook_thumbnail.png", tilemapName: "levelOne", maxPlayers: 4, size: "small"},
    {name: "Danger Desert", thumbnailKey: "thumbnails/danger_desert_thumbnail.png", tilemapName: "levelTwo", maxPlayers: 4, size: "medium"}
];

StageSelect.prototype = {
    init: function(gameId, rbts) {
        repeatingLavaTilesprite = rbts;
        this.gameId = gameId;
    },

    create: function() {
        this.backdrop = game.add.image(20, 25, "pong_textures", "lobby/lobby_backdrop");
        var backdropCenterX = this.backdrop.width/2;

        this.header = game.add.image(backdropCenterX, this.backdrop.height * 0.1, "pong_textures", "lobby/header");
        this.header.anchor.set(0.5);
        var headerText = game.add.bitmapText(
            0,
            3,
            "retro_font",
            "Select stage",
            30
        );
        headerText.anchor.set(0.5);
        this.header.addChild(headerText);

        this.selectedStageIndex = 0;
        var initialStage = stages[this.selectedStageIndex];

        this.leftButton = game.add.button(this.backdrop.width * 0.1, 180, "pong_textures", this.leftSelect, this, "button/left_select_button_02", "button/left_select_button_01");
        this.rightButton = game.add.button(this.backdrop.width * 0.75, 180, "pong_textures", this.rightSelect, this, "button/right_select_button_02", "button/right_select_button_01");
        this.okButton = game.add.button(this.backdrop.width * 0.8, this.backdrop.height * 0.85, "pong_textures", this.confirmStageSelection, this, "button/ok_button_02", "button/ok_button_01");

        this.leftButton.setDownSound(buttonClickSound);
        this.rightButton.setDownSound(buttonClickSound);
        this.okButton.setDownSound(buttonClickSound);

        this.thumbnail = game.add.image(backdropCenterX, this.backdrop.height/2 * 0.75, TEXTURES, initialStage.thumbnailKey);
        this.thumbnail.anchor.set(0.5);

        // Display title
        this.stageNameText = game.add.bitmapText(
            backdropCenterX,
            this.backdrop.height * 0.22,
            "retro_font",
            initialStage.name,
            30
        );
        this.stageNameText.anchor.set(0.5);

        this.backdrop.addChild(this.header);
        this.backdrop.addChild(this.thumbnail);
        this.backdrop.addChild(this.leftButton);
        this.backdrop.addChild(this.rightButton);
        this.backdrop.addChild(this.okButton);
        this.backdrop.addChild(this.stageNameText);
    },

    leftSelect: function() {
        if(this.selectedStageIndex === 0) {
            this.selectedStageIndex = stages.length - 1;
        } else {
            this.selectedStageIndex--;
        }

        this.updateStageInfo();
    },

    rightSelect: function() {
        if(this.selectedStageIndex === stages.length - 1) {
            this.selectedStageIndex = 0;
        } else {
            this.selectedStageIndex++;
        }

        this.updateStageInfo();
    },

    update: function() {
        repeatingLavaTilesprite.tilePosition.x++;
        repeatingLavaTilesprite.tilePosition.y--;
    },

    updateStageInfo: function() {
        var newStage = stages[this.selectedStageIndex];
        this.stageNameText.text = newStage.name;
        this.thumbnail.loadTexture(TEXTURES, newStage.thumbnailKey);
    },

    confirmStageSelection: function() {
        var selectedStage = stages[this.selectedStageIndex];

        socket.emit("select stage", {mapName: selectedStage.tilemapName});
        game.state.start("PendingGame", true, false, selectedStage.tilemapName, this.gameId, repeatingLavaTilesprite);
    }
};

},{}],14:[function(require,module,exports){
var Fader = require("../util/fader");

function TitleScreen() {
};


TitleScreen.prototype = {
    create: function() {
        this.titleOffsetX = game.width/2 * 0.1;
        this.titleOffsetY = game.height/2 * 0.25;
        this.buttonOffsetX = game.width/2 * 0.1;
        this.startButtonOffsetY = 275;
        this.howToButtonOffsetY = 340;
        this.volumeButtonOffsetX = game.width/2 * 1.75;
        this.volumeButtonOffsetY = game.height/2 * 0.1;

        this.showingInstructions = false;
        this.justClickedHowTo = false;
        this.justClickedOutOfHowTo = false;

        var mainThemeSound = game.add.audio("main_theme", .25);
        mainThemeSound.play();

        var background = game.add.sprite(0, 0, "pong_textures", "menu/menu_1");
        background.animations.add("menu_bg_animation", [
                "menu/menu_1",
                "menu/menu_2",
                "menu/menu_3",
                "menu/menu_4",
                "menu/menu_5",
                "menu/menu_6",
                "menu/menu_7",
                "menu/menu_8"
            ], 6, true);

        background.animations.play("menu_bg_animation");

        var title = game.add.image(this.titleOffsetX, 0, "pong_textures", "menu/menu_title");
        var titleTween = game.add.tween(title);
        titleTween.to({y: this.titleOffsetY}, 1000, Phaser.Easing.Bounce.Out, true, 200).start();

        this.createButtons();

        var startButtonTween = this.createInitialButtonTween(this.startButton, 200);
        var howToButtonTween = this.createInitialButtonTween(this.howToButton, 400);
        startButtonTween.start();
        howToButtonTween.start();
    },

    createInitialButtonTween: function(button, delay) {
        return game.add.tween(button).to({x: this.buttonOffsetX}, 500, Phaser.Easing.Default, false, delay);
    },

    createButtons: function() {
         this.volumeButton = game.add.button(this.volumeButtonOffsetX, this.volumeButtonOffsetY, "pong_textures", function() {
            // Global mute!  Use this.sound.mute to mute a single sound
            if (this.game.sound.mute) {
                this.game.sound.mute = false;
                this.volumeButton.setFrames("button/volume_on");
            } else {
                this.game.sound.mute = true;
                this.volumeButton.setFrames("button/volume_off");
            }
        }, this, "button/volume_on", "button/volume_on");
        
        this.startButton = game.add.button(this.buttonOffsetX - 250, this.startButtonOffsetY, "pong_textures", function() {
            if(!this.showingInstructions && !this.justClickedOutOfHowTo) {
                Fader.fadeOut(function() {
                    game.state.start("Lobby");
                });
            }
        }, this, "button/lava_button_2", "button/lava_button_1");
        this.startButton.setDownSound(buttonClickSound);
        
        var startText = this.game.add.bitmapText(
            this.startButton.width/2, 
            this.startButton.height/2, 
            "retro_font",
            "START GAME", 
            20  
        );
        startText.anchor.set(0.5);
        this.startButton.addChild(startText);

        this.howToButton = game.add.button(this.buttonOffsetX - 250, this.howToButtonOffsetY, "pong_textures", function() {
            if(!this.showingInstructions && !this.justClickedOutOfHowTo) {
                this.showingInstructions = true;
                Fader.fadeOut(function() {
                    this.howTo = game.add.image(0, 0, TEXTURES, "titlescreen/howtoplay.png");
                    this.justClickedHowTo = true;
                    Fader.fadeIn();
                }, this);
            }
        }, this, "button/lava_button_2", "button/lava_button_1");
        
        var howToText = this.game.add.bitmapText(
            this.howToButton.width/2, 
            this.howToButton.height/2, 
            "retro_font",
            "HOW TO PLAY", 
            20  
        );
        howToText.anchor.set(0.5);
        this.howToButton.addChild(howToText);
        this.howToButton.setDownSound(buttonClickSound);
    },

    update: function() {
        if(!game.input.activePointer.isDown && this.justClickedHowTo) {
            this.justClickedHowTo = false;
        }

        if(!game.input.activePointer.isDown && this.justClickedOutOfHowTo) {
            this.justClickedOutOfHowTo = false;
        }

        if(game.input.activePointer.isDown && this.showingInstructions && !this.justClickedHowTo) {
            buttonClickSound.play();
            this.showingInstructions = false;
            this.justClickedOutOfHowTo = true;
            Fader.fadeOut(function() {
                this.howTo.destroy();
                Fader.fadeIn();
            }, this);
        }
    }
}

module.exports = TitleScreen;

},{"../util/fader":16}],15:[function(require,module,exports){
var bombSound;
var powerupSound;

module.exports = {
	initialize: function() {
		bombSound = game.add.audio("explosion");
		powerupSound = game.add.audio("powerup");
	},

	playBombSound: function() {
		bombSound.play();
	},

	playPowerupSound: function() {
		powerupSound.play();
	}
}
},{}],16:[function(require,module,exports){
var BLACK_HEX_CODE = "#000000";

module.exports = {
	createFadeTween: function (alphaFrom, alphaTo, fadeDuration) {
		fadeDuration = fadeDuration || 300;

		if(this.fadeGraphic) {
			this.fadeGraphic.destroy();
		}

		this.fadeGraphic = game.add.graphics(0, 0);
		this.fadeGraphic.beginFill(BLACK_HEX_CODE, 1);
		this.fadeGraphic.drawRect(0, 0, game.camera.width, game.camera.height);
		this.fadeGraphic.fixedToCamera = true;

		this.fadeGraphic.alpha = alphaFrom;
		this.fadeGraphic.endFill();

		var tween = game.add.tween(this.fadeGraphic);
		tween.to({alpha: alphaTo}, fadeDuration, Phaser.Easing.Default);
		return tween;
	},

	createFadeInTween: function(fadeDuration) {
		return this.createFadeTween(1, 0, fadeDuration);
	},

	createFadeOutTween: function(fadeDuration) {
		return this.createFadeTween(0, 1, fadeDuration);
	},

	fadeOut: function(callback, callbackContext, fadeDuration) {
		callbackContext = callbackContext ? callbackContext : this;

		var fadeOutTween = this.createFadeOutTween(fadeDuration);
		
		if(typeof callback === 'function') {
			fadeOutTween.onComplete.add(callback, callbackContext);
		}

		fadeOutTween.start();
	},

	fadeIn: function(callback, callbackContext, fadeDuration) {
		callbackContext = callbackContext ? callbackContext : this;

		var fadeInTween = this.createFadeInTween(fadeDuration);

		if(typeof callback === 'function') {
			fadeInTween.onComplete.add(callback, this);
		}

		fadeInTween.start();
	}
}
},{}],17:[function(require,module,exports){
exports.configureText = function(text, color, size) {
	text.font = "Consolas";
	text.fill = color;
	text.fontSize = size;
}
},{}]},{},[1]);
